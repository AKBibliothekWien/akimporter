# #########################################################################################################################################
#
# Options
# Add options to the end of a line, seperated by comma! Possible options are:
#
#
# - multiValued
#   If more than one value should be indexed. Attention: The Solr field for indexing must be able to hold more than one value
#   (see also <field>-tags in Solr schema.xml). If you don't use multiValued, only the first none-empty value will be indexed.
#   Example:
#      title_alt: 310$**$*, 340$**$*, 344$**$*
#   If 340$**$* and 344$**$* have a value, only the 340$**$* will be indexed. If you define the rule with "multiValued", all
#   values will be indexed. This would be:
#      title_alt: 310$**$*, 340$**$*, 344$**$*, multiValued
#
#
# - customText
#   You may specify a custom text that will be written into the given Solr field.
#   Example:
#      title: This is my title, customText
#   In this example, the text "This is my title" would be indexed to the Solr field "title".
#
#
# - translateValue (can be combined with "multiValued" and "defaultValue")
#   You may translate an exact value (for non-exact values, see translateValueContains and translateValueRegex) from a given
#   MAB-field to a value you like to use. You need also to specify a translation file with the suffix ".properties". This file
#   has to be saved in the same directory as the AkImporter.jar file.
#   Example to match the first character of the MAB field 051:
#      pubType: 051[1-1], translateValue, publicationtype.properties
#   In publicationtype.properties, you could define a mapping like this:
#      a = Article
#      p = Journal
#      r = Series
#      m = Monograph
#   In the above example, we match only the first character with [1-1]. If you would like to match the first 3 characters,
#   you could use "051[1-3]". If you would like to match all characters, you could use "051[all]".
#   It is also possible to define a default value that is used if no appropriate value is found in the .properties file. Use
#   the defaultValue option for that (see below). Be aware that the default value is not used if the MAB-Field itself does not
#   exist in the record. That means, in the above example, the default value would not be written to the index if the MAB field
#   051 would not exist.
#     
#   
# - translateValueContains (can be combined with "multiValued" and "defaultValue")
#   This is the same as translateValue but the match doesn't have to be exact. An Example: In our bibliographic data, imagine
#   we have non-standard description texts for URLs in our 655$e*$z MAB field. Examples are: "This fulltext was digitized by library XYZ",
#   "Link to fulltext", "Fulltext and abstract", etc. But in our index, we only want the have the value "Fulltext" because we want
#   to build a facet field (filter) with it.
#   To do that, we could use a rule like this one:
#      urlText_str_mv: 655$e*$z[all], 655$e*$3[all], translateValueContains, urltext.properties
#   In the file urltext.properties, which must be saved in the same directory as AkImporter.jar, you could define a mapping like this:
#      fulltext = Fulltext
#      Fulltext = Fulltext
#   Every text in MAB fields 655$e*$z or 655$e*$3 that contains "fulltext" or "Fulltext" (please be aware of case sensitivity), no
#   matter if it also contains other text before or after that word, will be translated to "Fulltext".
#   Please be also aware that a space in a property key needs to be escaped with a backslash (\). Example:
#      Digital\ object = Fulltext
#   It is also possible to define a default value that is used if no appropriate value is found in the .properties file. Use
#   the defaultValue option for that (see below). Be aware that the default value is not used if the MAB-Field itself does not exist in
#   the record. Example:
#      051[1-1], translateValueContains, publicationtype.properties, defaultValue[NoPubtypDefined]
#   Explanation: If the first value of field 051 would not match a value in the .properties file with the mappings, the value
#   "NoPubtypDefined" would be used. If field 051 would not exist in the record you try to index, no value would be written to
#   the index.
#
#
# - translateValueRegex (can be combined with "multiValued" and "defaultValue")
#   Same as translateValue but in the translate .properties file that you define, you can use RegEx patterns for translating. This can be necessary if
#   your tanslation has to be position aware, e. g. for encoded fields like MAB 050. In this field you could have an "a" on position 4 (|||a||||||||||)
#   or an "a" on position 9 (||||||||a|||||). Both characters are an "a" but their meaning is different because they are on  a different positions.
#   Additionally, also in the translate .properties file, you have to specify the field name to which the RegEx should be applied. That is
#   necessary because different fields could have the same character on the same position. E. g. MAB field 050 has an "a" on positon 4
#   (|||a||||||||||) and MAB field 052 has also an "a" on positon 4 (|||a||||||||||). Each "a", even when in the same position, means different
#   things because they are in different fields. That is why you have to specify the field name, e. g. 050 or 100$*a*a. If the RegEx should be
#   applied to all fields of the rule, just use "any". The field name or "any" has to be written before the RegEx rule and has to be separated
#   by it with the pipe character "|".
#   Example:
#      format: 050[all], 051[all], 052[all], translateValueRegex, format.properties, defaultValue[FormatUnknown], multiValued
#   Read this rule like this: For the Solr "format" field, take all characters from MAB fields 050, 051 and 052 and apply the translateValueRegex
#   option. The translation rules a in the file format.properties, which must be in the same directory as AkImporter.jar. If no translation was
#   found, use write the value "FormatUnknown" to the index (this is optional and applies only if at least one of the 3 fields 050, 051 or 052
#   does exist in the record). The "multiValued" option indicates that multiple values can be written to Solr field "format".
#   In format.properties, you could define the following rules. Please be aware that you have to escape a backslash with another backslash (e. g.
#   \\d for numbers):
#      050|^...a = Microform
#      050|^........a = Computer-File
#      051|^........a = Book
#      any|\\d+ = Numbers
#   Read the rules like this:
#      1. line: look for RegEx pattern "^...a", but only in the 050 field.
#               If it is found, write "Microform" to the index.
#      2. line: look for RegEx pattern "^........a", but only in the 050 field.
#               If it is found, write "Computer-File" to the index.
#      3. line: look for RegEx pattern "^........a", but only in the 051 field.
#               If it is found, write "Book" to the index.
#      4. line: look for RegEx pattern "\\d+" in all given fields (in the example rule above these are 050, 051 and 052).
#               If it is found, write "Numbers" to the index.
#      If none of the RegEx patterns will match, the default value (in our example "FormatUnknown") would be written to the Solr field "format".
#      If the defaultValue options is not used and no RegEx pattern matches, nothing will be indexed, that means that the Solr field "format" would
#      not exist for the record that is processed.
#
#
# - defaultValue[VALUE] (only in combination with "translateValue", "translateValueContains" and "translateValueRegex")
#   You can define a default value which will be indexed in case no other value was found in a translate properties file.
#   Example:
#      urlText_str_mv: 655$e*$z[all], 655$e*$3[all], multiValued, translateValueContains, urltext.properties, defaultValue[NoUrlText]
#   In this example, the text "NoUrlText" would be used if no appropriate value was found in the translate properties file.
#   NOTE: Be aware that the default value is NOT used if the MAB-Field itself does NOT exist in the record (your bibliogrphic XML data).
#   For the example above this would mean that "NoUrlText" would NOT be used if neither the field 655$e*$z, nor the field 655$e*$3 would
#   exist in the record that is processed.
#
#
# - regEx[REGEX] (can be combined with "translateValue", "translateValueContains" and "translateValueRegex" [with or without "defaultValue"])
#   You can use regular expressions. If a value matches the regular expression, the match will be indexed instead of the original value.
#   Example:
#      425$a*$a, regEx[\\d+]
#   The example would match only numbers in field 425$a*$a. If there would be a date like "ca. 1925", only the value "1925" (without "ca. ")
#   would be indexed.
#   NOTE: Be aware that you have to escape backslashes with another backslash (\\), e. g. for \\d or \\[.
#   If you combine "regEx" with "translateValue", "translateValueContains" or "translateValueRegex", the regular expression will be applied to
#   the "raw" value from your bibliographic data before the translating process (using the translation properties files) takes place.
#   If the regular expression does not match, then the original value is indexed to prevent the loss of data. For indexing only matched
#   values, see "regExStrict" below.
#
#
# - regExStrict[REGEX] (can be combined with "translateValue", "translateValueContains" and "translateValueRegex" [with or without "defaultValue"])
#   Same as "regEx" above, but indexes only values that matches the regular expression. The original value will NOT be indexed if the regular expression
#   does not match! This could lead to the loss of data!
#
#
# - allowDuplicates (only useful for a multivalued field)
#   By default, no duplicate values are indexed in multivalued fields. That is to avoid useless data overhead and falsifying search results
#   (a Solr document that has multiple occurences of the same value is rated higher in the search rank). But if a multivalued field should be 
#   able to contain duplicate values, you may enable it with this option.
#
#
# - connectedSubfields[subfield:subfield:subfield: ...]
#   Sometimes, a specific subfield needs to have a "twin" value. Imagine the following: We have 3 fields 655$e*$u containing a URL.
#   Then we also have 1 field 655$e*$z and 1 field 655$e*$3, each conaining a description for one of the URLs (e. g. Fulltext,
#   Table of Contents). So we have 3 URLs but only 2 descriptions. The problem is that, while showing the values for the user in the
#   frontend, the URLs and the descriptions could shift in a way that the descripton "Fulltext" would be connected with a URL that
#   is actually not pointing to the fulltext. At the bottomline: There are values that are connected to other values and need to be
#   displayed accurately for the user, and that's why we need the same number of values (value1a - value1b, value2a - value2b, etc.)
#   In that case, you can use connectedSubfields[subfield:subfield:subfield:...:DefaultText].
#   Example:
#      url: 655$e*$u, connectedSubfields[3:z:DefaultText], multiValued
#   Read the example like this: If 655$e*$u exists, and subfield 3 or z also exists, the value of 3 or z will be indexed as a
#   connected subfield value. It will be the value of the first connected subfield (3 or z) that occurs in the XML data. But if
#   subfields 3 or z of the same 655 field don't exist, the default value "DefaultText" will be written as a connected value.
#   The default value is always the last specified value in the list wihin the square brackets, that must be separated with a colon. 
#   The result is that in the Solr field "url", at least 2 values will be indexed. One "master value" (the one from subfield "u")
#   and one connected value (either the value of subfield 3 or z [whichever comes first] or the default value). If there would be
#   another 655$e*$u in our XML data, another 2 values would be indexed in Solr field "url", so it would be 4 values. The result would
#   look somewhat like this:
#      "http://url/to/fulltext",			[= master value]
#      "Fulltext"							[= connected value]
#      "http://url/to/tableofcontents		[= master value]
#      "Table of contents"					[= connected value]
#   We now have alternating "master values" and "connected values" as pairs (1+2, 3+4, ...) that we could use in our frontend for
#   displaying correct links, e. g.
#      <a href="http://url/to/fulltext">Fulltext</a>
#      <a href="http://url/to/tableofcontents">Table of contents</a>
#
#   
#
# Note on Solr field "recordtype"
# Field for recordtype should contain "mab" and the option "customText" should be used. This would be:
#      recordtype: mab, customText
#
# Note on Solr field "allfields"
# This field contains all values of all other Solr fields except the ones in square brackets (separated by colon).
# It uses a special option to achieve that. Always use it like this and only on field "allfields":
#      allfields: getAllFields[Solrfield1:Solrfield2:Solrfield3]
# We need to except fields because "allfields" is used for spell checking and we don't want to have values of e. g.
# encoded fields (e. g. MAB fields 050, 051, etc.) for that. Be aware to use Solr fieldnames for the exceptions, not
# MAB fieldnames, e. g. instead of 001$**$* you should use "acNo_txt".
#
# Note on Solr field "fullrecord"
# This field should contain the full record as MarcXML or Marc21. As our MAB data are delivered as MarcXML, we use this
# format. We can use the option "getFullRecordAsXML". Should be only used on Solr field "fullrecord" like this:
#      fullrecord: getFullRecordAsXML
#
# #########################################################################################################################################

# AkSearch addidional dynamic fields
leader_str: LDR
sysNo_txt: SYS
deleted_str: DEL$**$*
acNo_txt: 001$**$*
satztyp_str: FMT
parentMultiAC_str: 010$**$*
parentSeriesAC_str_mv: 453$**$*, 463$**$*, 473$**$*, multiValued
multiVolumeNo_str: 089$**$*
multiVolumeNoSort_str: 090$**$*
serialVolumeNo_str: 455$**$*
serialVolumeNoSort_str: 456$**$*
itmLink_str_mv: 456$i*$*, multiValued
formatCode_str: 050
begrenzteWerke_str: 051
fortlaufendeWerke_str: 052
erscheinungsform_str: 051[1-1], 052[1-1], translateValue, erscheinungsformen.properties, defaultValue[NoErscheinungsform]
publishPlace_txt: 410$**$*, 419$**$a
urlText_str_mv: 655$e*$z, 655$e*$3, multiValued
urlMimeType_str_mv: 655$e*$q, multiValued
datePublishSort_str: 425$a*$a, regEx[\\d+]
datePublishFirst_str: 425$b*$*
datePublishLast_str: 425$c*$*
contentType_str_mv: 060$**$*, multiValued
mediaType_str_mv: 061$**$*, multiValued
author_GndNo_str: 100$**$9
author2_GndNo_str: 104$**$9
author_additional_NameGnd_txt_mv: 108$**$p, 112$**$p, 116$**$p, 120$**$p, multiValued
author_additional_GndNo_str_mv: 108$**$9, 112$**$9, 116$**$9, 120$**$9, multiValued
corporateAuthorName_txt: 200$**$k, 200$**$a
corporateAuthorGndNo_str: 200$**$9
corporateAuthor2Name_txt_mv: 204$**$a, 208$**$a, 212$**$a, 216$**$a, multiValued
corporateAuthor2NameGnd_txt_mv: 204$**$k, 208$**$k, 212$**$k, 216$**$k, multiValued
corporateAuthor2GndNo_str_mv: 204$**$9, 208$**$9, 212$**$9, 216$**$9, multiValued
pubFrequency_str: 523$**$*
customField_txt_mv: 086$**$*, multiValued
responsibilityNote_txt: 359$**$*
location_txtF: AVA$**$j, Z30$**$2
locationCode_str: AVA$**$j, Z30$**$2
sublibrary_str: AVA$**$b, Z30$**$1
callnumber_txt: AVA$**$d, Z30$**$3

subjectGndNo_str_mv: 902$**$9, 907$**$9, 912$**$9, SWD$**$9, PER$**$9, KOR$**$9, multiValued
subjectBKL_txt_mv: BKL$**$a, multiValued
subjectSWD_txt_mv: SWD$**$s, SWD$**$p, SWD$**$k, SWD$**$g, SWD$**$x, SWD$**$h, multiValued
subjectPER_txt_mv: PER$**$p, multiValued
subjectKOR_txt_mv: KOR$**$k, multiValued
subjectAdditional_txt_mv: 710$**$a, 720$**$a, 740$**$a, multiValued

articleParentAC_str: 599$-*$*
articleParentYear_str: 595$**$*
articleParentVolumeNo_str: 596$i*$*, 596$a*$*, 596$**$*
articleParentTitle_txt: 590$**$*, 525$**$a

otherEditionType_txt_mv: 527$**$p, multiValued
otherEditionTitle_txt_mv: 527$**$a, multiValued
otherEditionComment_txt_mv: 527$**$n, multiValued
otherEditionAC_str_mv: 527$**$9, multiValued

attachmentType_txt_mv: 529$**$p, multiValued
attachmentTitle_txt_mv: 529$**$a, multiValued
attachmentComment_txt_mv: 529$**$n, multiValued
attachmentAC_str_mv: 529$**$9, multiValued



# VuFind original fields
id: SYS
recordtype: mab, customText
allfields: getAllFields[leader_str:sysNo_txt:deleted_str:acNo_txt:satztyp_str:parentMultiAC_str:parentSeriesAC_str_mv:multiVolumeNo_str:multiVolumeNoSort_str:serialVolumeNo_str:serialVolumeNoSort_str:itmLink_str_mv:formatCode_str:begrenzteWerke_str:fortlaufendeWerke_str:urlMimeType_str_mv:contentType_str_mv:mediaType_str_mv:author_GndNo_str:author2_GndNo_str:author_additional_GndNo_str_mv:corporateAuthorGndNo_str:corporateAuthor2GndNo_str_mv:locationCode_str:callnumber_txt:subjectGndNo_str_mv:articleParentAC_str:articleParentVolumeNo_str:otherEditionType_txt_mv:otherEditionAC_str_mv:attachmentAC_str_mv:id:recordtype:collection:url:isbn:issn:oclc_num:callnumber-first:callnumber-subject:callnumber-label:callnumber-sort:callnumber-raw]
fullrecord: getFullRecordAsXML
collection: AVA$**$b, multiValued
language: 037$b*$a, multiValued
format: 050[all], 051[all], 052[all], translateValueRegex, format.properties, multiValued
author: 100$**$p, 100$**$a
author-letter: 100$**$p, 100$**$a
author2: 104$**$p, 104$**$a
author_additional: 108$**$a, 112$**$a, 116$**$a, 120$**$a, multiValued
title: 331$**$*, 335$**$*
title_sort: 331$**$*
title_sub: 335$**$*
title_short: 331$**$*
title_full: 331$**$*, 335$**$*
title_auth: 331$**$*, 335$**$*
title_alt: 310$**$*, 340$**$*, 344$**$*, 352$**$*, 370$**$*, 504$**$*, 505$**$*, 670$**$*, 675$**$*, multiValued
title_old: 531$**$a, 532$**$a, multiValued
title_new: 533$**$a, multiValued
dateSpan: 405$**$*, multiValued
series: 451$**$*, 454$**$*, 461$**$*, 464$**$*, multiValued
topic: 902$**$p, 902$**$g, 902$**$s, 902$**$k, 902$**$c, 902$**$z, 902$**$f, 902$**$t, 907$**$p, 907$**$g, 907$**$s, 907$**$k, 907$**$c, 907$**$z, 907$**$f, 907$**$t, 912$**$p, 912$**$g, 912$**$s, 912$**$k, 912$**$c, 912$**$z, 912$**$f, 912$**$t, multiValued
topic_facet: 902$**$p, 902$**$g, 902$**$s, 902$**$k, 902$**$c, 902$**$z, 902$**$f, 902$**$t, 907$**$p, 907$**$g, 907$**$s, 907$**$k, 907$**$c, 907$**$z, 907$**$f, 907$**$t, 912$**$p, 912$**$g, 912$**$s, 912$**$k, 912$**$c, 912$**$z, 912$**$f, 912$**$t, multiValued
genre: 902$**$f, 907$**$f, 912$**$f, 661$d*$*, multiValued
genre_facet: 902$**$f, 907$**$f, 912$**$f, 661$d*$*, multiValued
geographic: 902$**$g, 907$**$g, 912$**$g, multiValued
geographic_facet: 902$-*$g, 907$**$g, 912$**$g, multiValued
era: 902$**$z, 907$**$z, 912$**$z, multiValued
era_facet: 902$-*$z, 907$**$z, 912$**$z, multiValued
illustrated: 434$-*$*
physical: 433$**$*, 434$**$*, 435$**$*, 437$**$*, 540$**$b, 542$**$b, 653$-*$a, 653$-*$c, 653$-*$d, 653$-*$e, multiValued
publisher: 412$**$*, 419$**$b, multiValued
publishDate: 425$a*$*, multiValued
publishDateSort: 425$a*$a, regExStrict[\\d+]
edition: 403$**$*
contents: 517$**$c, 517$**$b, multiValued
url: 655$e*$u, connectedSubfields[3:z:NoDisplayText], multiValued
isbn: 540$a*$a, 540$b*$a, 540$-*$a, 452$c*$*, 452$d*$*, 599$c*$*, 599$d*$*, 622$c*$*, 622$d*$*, multiValued
issn: 542$a*$a, 542$b*$a, 542$-*$a, 452$a*$*, 452$b*$*, 599$a*$*, 599$b*$*, 622$a*$*, 622$b*$*, multiValued
oclc_num: 026$**$*, multiValued
dewey-full: 700$b*$a, 700$x*$a, multiValued
dewey-raw: 700$b*$a, 700$x*$a, multiValued
callnumber-first: AVA$**$d, Z30$**$3
callnumber-subject: AVA$**$d, Z30$**$3
callnumber-label: AVA$**$d, Z30$**$3
callnumber-sort: AVA$**$d, Z30$**$3
callnumber-raw: AVA$**$d, Z30$**$3